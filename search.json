[{"lang":"en","lvl2":"Sample\nInjections\nLaunching","text":"Mark a bean with @Command to make it a command. You can customize the command name (first command line value to call the command) and its description (usage/help on error),\nEnsure to make the command a Runnable,\nEnsure to have a constructor with the first parameter (required) being the configuration class (as in configuration),\nImplement your command in run callback,\nThe configuration of the command is a standard one, you can customize the prefix thanks @RootConfiguration annotation (so here all options will use --my-command-xxxx instead of default --Conf-xxx).\nif you don’t want to set any prefix for the configuration, set the prefix in @RootConfiguration to -.\nYou can inject any simple type (classes, not lists) beans in your command through the constructor (> first parameter).\nif you need to inject a list, you can always create a bean which holds the list and inject this wrapper in your command.\nfusion-cli provides an integration with Launcher main, if you don’t use it, you will have to call yourself CLIAwaiter and register an instance of Args.","title":"CLI","url":"//www.yupiik.io/fusion/fusion/cli.html"},{"lang":"en","lvl2":"Defining a Bean without injections\nDefining a Bean with injection(s)\nCreate a bean in a custom fashion without a class\nInjection of a list/set\nListen to an event\nEmit an event\nCreate a configuration model\nCreate a JSON model\nHandle unknown JSON attributes\nDefine a custom HTTP endpoint\nDefine a JSON-RPC endpoint\nDefine a \"reactive\" JSON-RPC endpoint\nRegister OpenRPC endpoint\nStart the container\nTest with JUnit 5","lvl3":"Implement a custom explicit Endpoint bean\nImplement a custom implicit Endpoint","text":"If a bean has an injection or an event listener it will be automatically defined as a bean, but in some cases, you want to define a bean on a plain class without any injection nor event listener. For such a case, you can mark the class with @Bean:\nThis simple definition enables you to inject this bean in other beans.\nThe common use case of a framework is to get injected some bean without exactly knowing how it was created or initialized. Here is how to get an injection with Fusion framework:\ndo NOT use private fields, it is not yet supported.\nAlternatively, you can use constructor injections:\nThe injected values can be defined normally since injections happen with the constructor, you can even precompute the data you need in the bean and not store the injection itself,\nThe constructor injection (the selected one is the most public one - public wins over protected) and with the most parameters,\nThe no-arg constructor - only needed for scopes using subclassing like @ApplicationScoped.\nIt can happen you need to reuse some custom factory and code the initialization of a bean. For such a case you can mark a method with @Bean. Injections can be done in the enclosing bean if needed:\nas of today, you can mark the producer method with a scope but lazy scopes (like @ApplicationScoped are not really lazy until you implement yourself the lazyness - but scope is respected, i.e. if it is @ApplicationScoped it will be a singleton).\nif the returned type implements AutoCloseable, close() will be called to destroy the bean instance(s).\ninjections of List or Set are done by resolving the parameter type of the injection.\nyou can put on the implementations (or beans) the annotation @Order to sort their position in the List - ignored for Set.\nBeans can communicate loosely between them thanks to events. The bus is synchronous and sorted using @Order annotation.\nExample of ordered event listener (default being 1000):\nlistening to Start event can enable a lazy instance (@ApplicationScoped) to be forced to be initialized.\nan event can have more parameters, other parameters will be considered as injections (but the lookup will be destroyed after the method call if it is not @ApplicationScoped)\nTo emit an event simply inject the Emitter and send the needed event:\nA configuration model is a record marked with @RootConfiguration:\nThis simple configuration will read the system properties server.port, server.accessLogPattern (or environment variables SERVER_PORT, SERVER_ACCESSLOGPATTERN) to fill the values. The instance of ServerConfiguration can be injected in any bean:\nIf you want to customize the name of the property you can use @Property.\nFinally, you can register you own source of values creating a bean of type ConfigurationSource.\nList<OtherConfig> are supported, but you must set in the configuration <prefix for this list>.length to the length value of the list then the nested instances are configured using <prefix>.<index> starting at index 0. Ex: myconf.mylist.0.name=foo.\nA JSON model is a record marked with @JsonModel:\nThen simply inject the JsonMapper in any bean to read/write such a model:\nThis will match this JSON:\nAnd convert it to the following record mapping: MyModel[name=fusion, extensions={x-foo=true,boney=M}].\nyou can use the configuration entry fusion.jsonrpc.binding to change the /jsonrpc default binding. You can also set fusion.jsonrpc.forceInputStreamUsage to true to force the input to be reactive instead of using default request Reader.\nIt is possible to register an OpenRPC endpoint named openrpc to serve JSON-RPC specification:\nTo launch the application you need to start the container. It is done in two phases:\nConfigure the runtime\nLaunch the runtime.\nHere is how to do it:\nGet a ConfiguringContainer which enables you to disable bean autodiscovery, to replace beans etc…\nLaunch the runtime container (you can look up beans there).\nyou can also just reuse io.yupiik.fusion.framework.api.main.Launcher main which will start the default container. You can implement a custom Awaiter to not let the container shutdown immediately if you need - webserver does it by default. Finally you can also, using this launcher, inject Args to read the main arguments.\nMark the class to run tests under a container context (it is started/stopped automatically),\nInject container beans in test parameters (mark them with @Fusion).\nAlternatively you can run a single container for all tests:","title":"Example","url":"//www.yupiik.io/fusion/fusion/examples.html"},{"lang":"en","lvl2":"Dependency\nUsage\nEach built-in helper data-variables\nFuture","text":"It starts from HandlebarsCompiler (available as a fusion bean) which compiles a template + its helpers and partials as a Template which supports to render the template.\nData can be map of primitives (or data which have a toString()) or lists for now. It tolerates that you pass a Supplier too as map value for a lazy evaluation.\n{{each xxx} supports the following data-variables:\n@first (boolean): is the current element the first one,\n@last (boolean): is the current element the last one,\n@index (integer): 0-based index of current element.\nIf the xxx variable is not a Collection but a Map, the additional @key and @value data-variables are available.\nTechnically it is possible to go further but it has to be proven useful, here are some ideas:\nSupport records (potentially POJO but immutability would be a plus) as model,\nSupport CompletionStage as model - requires to return a CompletionStage<String> instead but generally we can always await the model is available before the rendering and making helpers promise friendly has other drawbacks,\nSupport to precompile the template at build time, this can use an API like public interface MyTemplates { @HandleBars(template = \"myresource.handlebars\") String myResource(MyRecordDataOrMap data); } and fusion processor would generate an implementation of this type which would be a bean. This option requires to override most of *Part implementations but is very feasible,\nSupport more this cases, right now a few cases don’t support this keyword,\nSupport lookup, this is built-in in handlebars but has the drawback to rely on lookup at runtimes, maybe something to not add,\nSupport streaming? If the output can be huge - assuming we support later Iterable or Stream for example - then we can replace the output String by a InputStream or a Publisher<ByteBuffer> for ex,\nCorrect whitespace control (https://handlebarsjs.com/guide/expressions.html#subexpressions),\nElse support (in if blocks),\n…","title":"Fusion Handlebars","url":"//www.yupiik.io/fusion/fusion/handlebars.html"},{"lang":"en","lvl2":"Example\nRunner flavors\nTesting a Launcher application","text":"There are two runner flavors:\nFusionSupport which starts and stops the container per test class,\nMonoFusionSupport which starts and stops the container per JVM - faster but does not isolate all classes.\nusing a custom JUnit 5 Extension where you set system properties in a static block, you can configure the container before it starts. It is recommended to combine it in a custom annotation to control the ordering and ease the usage: @Target(TYPE)\n@Retention(RUNTIME)\n@MonoFusionSupport\n@ExtendsWith(MyAppSupport.MyConf.class)\npublic @interface MyAppSupport {\n    class MyConf implements Extension {\n        static {\n            // do the configuration\n            System.setProperty(\"....\", \"....\");\n        }\n    }\n} Then simply replace fusion annotation by MyAppSupport. Alternatively you can register a test ConfigurationSource bean if you prefer but this extension option enables to also start global services like dependencies mock or a database.\nusing a custom JUnit 5 Extension where you set system properties in a static block, you can configure the container before it starts. It is recommended to combine it in a custom annotation to control the ordering and ease the usage:\nThen simply replace fusion annotation by MyAppSupport.\nAlternatively you can register a test ConfigurationSource bean if you prefer but this extension option enables to also start global services like dependencies mock or a database.\nParticularly for CLI applications (using an Launcher and an Awaiter getting Args injected for example), you can use @FusionCLITest as a replacement of @Test. It will enable you to get an automatic execution of Launcher based on the annotation args value and to get injected Stdout and Stderr to validate the outputs.\nargs are made available to Configuration thanks a dedicated ConfigurationSource which supports these style of arguments (all leading to foo=bar mapping): --foo bar, -foo bar, foo bar, --foo=bar, -foo=bar, foo=bar. A particular arg starting by fusion-properties will be replaced by loading its value (as Properties, it can be inline or a file path - preferred).","title":"Fusion Testing","url":"//www.yupiik.io/fusion/fusion/testing.html"},{"lang":"en","lvl2":"Core Values\nFeatures\nLimitations\nSetup\nExtension Modules","lvl3":"No interceptor support","text":"For cloud applications, being the most reactive possible is a key criteria so Fusion chose to:\nBe build time oriented: only delegate to runtime the bean resolution (to enable dynamic module aggregation) and not the bean and model discovery nor proxy generation,\nStay flexible: even if the model is generated at build time you can generally still customize it by removing a bean and adding your own one,\nBe native friendly: some applications need to be native to start very fast and bypass the classloading and a bunch of JVM init, for that purpose we ensure the framework is GraalVM friendly - using Apache Geronimo Arthur or not.\nField/constructor injections\nContexts/scopes\nDefault scope (@DefaultScoped) is to create an instance per lookup/injection\nApplication scope (@ApplicationScoped) creates an instance per container and instantiates it lazily (at first call)\nEvent bus\nStart/Stop events are fired with container related lifecycle hooks,\nLifecycle: @Init/@Destroy to react to the bean lifecycle,\nOptional<MyClass> injections,\nBasic cloud friendly configuration,\nAdding fusion-json module, you can get JSON records mapping support without reflection,\nAdding fusion-http-server module, you get an Apache Tomcat abstraction enabling to write any HTTP endpoint in an efficient and GraalVM friendly manner,\nAdding fusion-testing module, you get some JUnit 5 integration enabling to test easily your code.\nAdding fusion-cli module, you can generate simple CLI applications just writing commands.\nyou can find examples on the examples page.\nSince some years we got used to see declarative interceptors (annotations) like in this snippet:\nThese are great and the container is actually linking the annotation to an implementation (a bean in general) which intercepts the call. This is not bad but has some design pitfalls:\nMost interceptors will use parameters and for such a generic approach to work, it needs an Object[] (or List) of parameters. This is really not fast (it requires to allocate an array for that purpose).\nIt requires to know and understand the rules between class interceptors, method interceptors, appending/overriding when relevant plus the same with parent classes. All that can quickly become complex.\nIt is often static: once put on a method disabling an interceptor requires the underlying library to be able to do that or to use some advanced customization at startup to do it.\nFor these reasons, we think that we don’t need an interceptor solution in Fusion framework but we don’t say the underlying feature is pointless, not at all. However, thanks to a more modern programming style, we can use a more functional approach to solve the same problem. Therefore, previous example would rather become:\nThe big advantage is you can use some static utility if you want but also rely on beans and even combine more efficiently interceptions in a custom and configurable fashion:\ncan become:\nIf you compare the case with parameters it is way more efficient in general since you just do a standard parameter passing call:\ngoing with this solution can, however, get the chaining lambda pitfall (a.k.a. callback hell in JavaScript), to solve this one we encourage you to ensure your \"interceptor\" can be chained properly using the same kind of callback. Here is an example (the important part is more the signature than the fact it is a static method or a bean method): public static <T> Supplier<T> interceptor1(String marker, Map<String, String> data, Supplier<T> nested) {\n    return () -> {\n        logger.info(message(marker, data)); // interceptor role\n        return task.get();  // intercepted business, \"ic.proceed()\" in jakarta interceptor API\n    };\n}\n\n\npublic static <T> Supplier<T> interceptor12(Params params, Supplier<T> nested) {\n    // same kind of logic for the impl\n} Thanks this definition which commonly agreed to use Supplier<T> as the intercepted call and the fact interceptor methods return a call and not execute it directly, you can chain them more easily: public void storeCustomer(final Customer customer) {\n    interceptor2(\n            Params.of(customer),\n            interceptor1(\n                \"incoming-customer\", Map.of(\"id\", customer.id()),\n                () -> {\n                    // business code\n                }))\n    .get(); // trigger the actual execution, it is the terminal operation for the chain\n} If you want to go further you can use a Stream to represent that. Now an interceptor is a Function<Supplier<T>, Supplier<T>> so if you define the list of interceptors in a Stream, then you can just reduce them using the business function/logic as identity to have the actual invocation and execute it. Only detail to take care: ensure to reverse the stream to call the interceptor in order: public void storeCustomer(final Customer customer) {\n    Stream.<Function<Supplier<Void>, Supplier<Void>>>of(\n                // reversed chain of interceptor (i1 will be executed before i2)\n                delegate -> interceptor2(Params.of(customer), delegate),\n                delegate -> interceptor1(\"incoming-customer\", Map.of(\"id\", customer.id()), delegate)\n        )\n        // merge the stream of interceptors as one execution wrapper\n        .reduce(identity(), Function::andThen)\n        .apply(() -> { // apply to the actual business logic\n            System.out.println(\">Business\");\n            return null;\n        })\n        .get(); // execute it\n} Indeed in practise you can extract that kind of code in an utility and use something like: // utility\npublic static <T> T intercepted(final Supplier<T> execution, final Function<Supplier<T>, Supplier<T>>... interceptors) {\n    return Stream.of(interceptors)\n            .reduce(identity(), Function::andThen)\n            .apply(execution)\n            .get();\n}\n\n// usage\nintercepted(\n    () -> { // business logic\n        System.out.println(\">Business\");\n        return null;\n    },\n    // interceptors\n    delegate -> interceptor2(Params.of(customer), delegate),\n    delegate -> interceptor1(\"incoming-customer\", Map.of(\"id\", customer.id()), delegate)\n); This is what the class io.yupiik.fusion.framework.api.composable.Wraps does.\ngoing with this solution can, however, get the chaining lambda pitfall (a.k.a. callback hell in JavaScript), to solve this one we encourage you to ensure your \"interceptor\" can be chained properly using the same kind of callback.\nHere is an example (the important part is more the signature than the fact it is a static method or a bean method):\nThanks this definition which commonly agreed to use Supplier<T> as the intercepted call and the fact interceptor methods return a call and not execute it directly, you can chain them more easily:\nIf you want to go further you can use a Stream to represent that. Now an interceptor is a Function<Supplier<T>, Supplier<T>> so if you define the list of interceptors in a Stream, then you can just reduce them using the business function/logic as identity to have the actual invocation and execute it. Only detail to take care: ensure to reverse the stream to call the interceptor in order:\nIndeed in practise you can extract that kind of code in an utility and use something like:\nThis is what the class io.yupiik.fusion.framework.api.composable.Wraps does.\nLast tip: you interceptor can work with CompletionStage to add some behavior before/after the call even if the result is not computed synchronously ;).\nthese are limitations as of today, none are technically strong limitations we can’t fix at a later point if desired.\nA no-arg constructor must be available for any class bean,\nIf a method producer bean is AutoCloseable then it will be automatically closed,\nEvent methods can not be package scope if the enclosing bean uses a subclass proxy (like @ApplicationScoped context),\nConstructor injections are supported but for proxied scopes (@ApplicationScoped for ex) it requires a default no-arg constructor (in scope protected or public) in the class (if not existing the instantiation constructor will be called with null parameters),\nEvent bus listeners can only have the event as method parameter,\nOnly classes are supported exception for method producers which can return a ParameterizedType (ex: List<String>) but injections must exactly match this type and List/Set injections are handled by looking up all beans matching the parameter.\nSee setup page to see how to get your project started.\nJSON\nJWT validation\nHTTP Server\nHTTP Client\nObservability\nHandlebars\nPersistence","title":"Getting Started","url":"//www.yupiik.io/fusion/fusion/index.html"},{"lang":"en","text":"To convert your application to a native binary - assuming your dependencies are native friendly like Fusion framework, you can use Apache Geronimo Arthur maven plugin.\nAssuming you use this main for example:\nYou can just add this plugin:\nAnd run mvn package arthur:native-image and you will get your binary in target/.\nif you are a purist, and depending your needs and Arthur version you can need to add the following configuration to avoid warnings: <enableAllSecurityServices>false</enableAllSecurityServices>\n<allowIncompleteClasspath>false</allowIncompleteClasspath>\nif you are a purist, and depending your needs and Arthur version you can need to add the following configuration to avoid warnings:\nif you want a JUL implementation which is GraalVM friendly you can use yupiik Logging (yupiik-logging-jul dependency concretely which works smoothly with GraalVM and enables a runtime system property logging control) and configure it in Arthur Maven Plugin (or GraalVM native-image) using: <customOptions>\n  <customOption>-Djava.util.logging.manager=io.yupiik.logging.jul.YupiikLogManager</customOption>\n</customOptions>\nif you want a JUL implementation which is GraalVM friendly you can use yupiik Logging (yupiik-logging-jul dependency concretely which works smoothly with GraalVM and enables a runtime system property logging control) and configure it in Arthur Maven Plugin (or GraalVM native-image) using:","title":"GraalVM","url":"//www.yupiik.io/fusion/fusion/graalvm.html"},{"lang":"en","lvl2":"Request Listeners\nKubernetes client","lvl3":"Default Listeners\nSample usage\n(Open) Tracing","text":"Fusion HTTP Client is based on java.net.http.HttpClient. It is configured with ExtendedHttpClientConfiguration which enables to:\noptionally provide a configured HttpClient instance - otherwise the default JVM one is used,\noptionally provide a set of `RequestListener`s which listen for requests.\nRequest listener is a callback triggered before and after each request. It enables to store data before the requests in the caller context and execute some callback once the request is finished. To pass data between both steps (since the request can be asynchronous or not) it uses a State which can hold any data the listener needs.\nif you write custom listeners (to add OpenTracing capabilities for example), you can make them implement AutoCloseable and when closing the HTTP client the method will be called automatically.\nThis listener is pretty straight forward, if the request does not have a timeout, it sets it to the default one configured in the listener. It enables to enforce a global timeout to all requests.\nThis listener enforce a custom user-agent value. It defaults to chrome one.\nThis listener enables to force all exchanges to be logged.\nThis listener wraps another listener to filter the calls to before/after callbacks either based on the request or on the response. Can be useful to ignore some data (for example to only capture errors in HARDumperListener).\nfor ignoredPaths you can use the syntax regex:<java regex> to match more than an exact path at once.\nThis listener enables to capture a HAR dump of all exchanges which went through the client. It can be very useful to generate some test data you replay with a HAR server in a test or a demo environment.\nIt comes with its companion HARHttpClient which enables to replay a HAR without actually doing the requests.\na sibling listener called NDJSONDumperListener exists and allows to log each entry in a ND-JSON output (better in case of error but not standard). It can be combined to NDJSONHttpClient to replay captured requests (in order).\nthe HttpClient companions of these \"capture\" listeners must be used in sequential order (until you know you can parallelize them all) because there is no matching logic as of today of requests/responses to enable a wider reuse of captures.\nthis is not in the same module, you must add fusion-tracing module to get this feature.\ntracing module provides a Tomcat valve you can set up on your web container to add tracing capabilities to your Tomcat:\nThe configuration enables to customize the span tags and headers to enrich the request with,\nThe accumulator is what will send/log/… the spans once aggregated, ensure to configure it as needed,\nThe IdGenerator provides the span/trace identifiers, it must be compatible with your collector (hex for zipkin for example),\nActually a Supplier<Span>, the span evaluator enables to get parent span, here from the request in a webserver-tomcat using Tracingvalve but any evaluation will work,\nThe clock enables to timestamp the span and compute its duration,\nFinally, add the listener to your http client configuration and create your client.\nthe accumulator should generally be closed if you reuse AccumulatingSpanCollector. You can combine it with ZipkinFlusher to flush to a zipkin collector v2.\nkubernetes-client modules providers a HTTP Client already configured for Kubernetes in cluster connection (from a POD). This will typically be used from an operator or cloud native application to call Kubernetes API using a plain and very light HTTP Client from the JVM.\nindeed you can combine it with the enhanced HTTP Client configuring it in the KubernetesClientConfiguration. However, it is recommended to do it using setClientWrapper on the configuration and pass the automatically created client to ExtendedHttpClientConfiguration.setDelegate to avoid to have to handle the SSLContext yourself.\nUsage:\nas you can see, there is no need to pass the token to the request, it is done under the hood by the KubernetesClient. The other important note is that https://kubernetes.api is automatically replaced by the conf.getMaster() value. This enables your code to stay more straight forward in general but if you pass them, the client will handle it properly too.","title":"HTTP Client","url":"//www.yupiik.io/fusion/fusion/http-client.html"},{"lang":"en","lvl2":"Dependency\nUsage\nConfiguration\nHigh level API\n(Open) Tracing","text":"HTTP server module provides an abstraction over an Apache Tomcat server.\nannotations - design API - is in fusion-build-api and is only useful at build time.\nBy default, if you use Fusion IoC, the webservice will be started. You can customize the configuration listening for WebServer.Configuration event.\nDefining an endpoint can be done creating an Endpoint bean and implementing the matcher (matches) and handler which will return a Response thanks the builder:\nMost of the configuration can be customized using an event listener on WebServer.Configuration and unwrapping the instance as a TomcatWebServerConfiguration you have access to a full Tomcat server customization (HTTP/2.0, WebSocket and so on).\nHowever, there are a few system properties/environment variables (uppercased and with underscores instead of dots) you can set:\nTo skip the initialization of the server at startup: fusion.http-server.start=[true|false]. This can be useful to not start the server in tests for example,\nTo set the HTTP port to use: fusion.http-server.port=<port>, note that setting 0 will make the port random and you can inject WebServer.Configuration to read its value,\nTo set the host to use: fusion.http-server.host=<host>,\nTo set the access log pattern to use: fusion.http-server.accessLogPattern=<…>, see Tomcat documentation for pattern details,\nTo set the webapp directory: fusion.http-server.base=/path/to/www. It can be useful to serve static websites if you configure the right servlets,\nTo set the fusion default servlet mapping: fusion.http-server.fusionServletMapping=/. It can be useful if you want to bind it to a subcontext to use standard servlets for other things like serving base directory,\nTo set if UTF-8 is enforced (default) or not over the requests/responses: fusion.http-server.utf8Setup=true.\nThe first option to define an endpoint as a bean - automatically picked - is to use Endpoint.of API:\nThe alternative is to use @HttpMatcher API:\nif your endpoint is fully synchronous you can drop the CompletionStage wrapper: public CompletionStage<Response> myGreetingEndpoint();. You can also pass as first parameter a Request parameter.\nfusion-tracing module provides a Tomcat valve you can set up on your web container to add tracing capabilities to your Tomcat:\nAdd the valve to the context pipeline, it is recommended to add it as early as possible (just after error report and access log valve in general),\nThe configuration enables to customize the span tags and headers to read for span propagation,\nThe accumulator is what will send/log/… the spans once aggregated, ensure to configure it as needed,\nThe IdGenerator provides the span/trace identifiers, it must be compatible with your collector (hex for zipkin for example),\nFinally the clock enables to timestamp the span and compute its duration.\nif you reuse AccumulatingSpanCollector, it is automatically closed with the valve \"stop\" phase. You can combine the accumulator with ZipkinFlusher onFlush implementation to flush to a zipkin collector v2.","title":"HTTP Server","url":"//www.yupiik.io/fusion/fusion/http-server.html"},{"lang":"en","text":"","title":"Index","url":"//www.yupiik.io/fusion/index.html"},{"lang":"en","lvl2":"Runtime Dependency\nExample\nEnums","text":"Fusion JSON proposes a JsonMapper API which intends to support record models.\nHere the supported features list:\nModels must be records or List<X> of a supported type, or a Map<String, X> of a supported type\nSupported primitives are\nString\nString, BigDecimal (represented as string in JSON but incoming data can be a number), {b,B}oolean, {d,D}ouble, int/Integer, {l,L}ouble, OffsetDateTime, ZonedDateTime, LocalDate, LocalDateTime\nGeneric mapper is supported, it will bind Object as a Map<String, Object> values being String for JSON strings, BigDecimal for JSON numbers, another Map<String, Object> for JSON objects and List<Object> for JSON lists,\nA simple post processor prettifier (takes a JSON as input and formats it). It is used decorating the default JsonMapper: io.yupiik.fusion.json.pretty.PrettyJsonMapper,\nThe Fusion annotation processor will generate the JSON \"codecs\" from the code when a record is marked with @JsonModel, the codec will be reflection free,\nYou can customize the attribute names using @JsonProperty on the record members,\nYou can map all unknown attributes in a Map<String, Object> member marked with @JsonOthers annotation.\nstatic model (annotations) are in fusion-build-api which is a provided bundle - build time only.\nTo modelise the flow you just have to define a record marked with @JsonModel:\nThen read/write data using JsonMapper:\nEnumerations (de)serialization behavior can be customized by using some specific methods:\ntoJsonString is an instance method with no parameter used to replace .name() call during serialization,\nfromJsonString is a static method with a String parameter used to replace .valueOf(String) call during deserialization.","title":"JSON","url":"//www.yupiik.io/fusion/fusion/json.html"},{"lang":"en","lvl2":"Runtime Dependency\nUsage\nIntegration with web layer","text":"The JWT module intend to parse and validate a JWT just using fusion-json dependency and the JVM.\nMost of the time you will use an API gateway to do that but for advanced business validations or lighter architectures, it can make sense to do it in the application.\nEntry point is to inject a JwtvalidatorFactory (through constructor or @Injection on a field) and create an instance of validator passing a JwtValidatorConfiguration which sets the JWT algorithm, issuer, key etc…\nInject the validator factory and the JWT validator configuration (key, algorithm, …),\nCreate the runtime validator (once for the app),\nIf the JWT header is present extract it (or fail with an exception if invalid).\nFor JSON-RPC module, the easiest integration is to observe io.yupiik.fusion.jsonrpc.event.BeforeRequest event and plug your validation logic there (claim checks for example):\nLike in MyService (previous snippet), extract the jwt from the header checking/dropping Bearer prefix,\nValidate the JWT,\nCheck roles claim contains admin,\nComplete the request as failed (all requests if bulk is used).","title":"JWT validation","url":"//www.yupiik.io/fusion/fusion/jwt.html"},{"lang":"en","lvl2":"Observability\nHTTP Server\nHealth checks\nMetrics","text":"Observability stack is composed of these primitives:\nLogging: Yupiik Logging: it enables to configure your logging using system properties even using GraalVM native-image. It is also a good companion for container based deployments (Kubernetes) since you can switch very easily logging to JSON (-Djava.util.logging.manager=io.yupiik.logging.jul.YupiikLogManager -Dio.yupiik.logging.jul.handler.StandardHandler.formatter=json).\nHealthcheck(s): this is the capacity to test through HTTP the server state, mainly used by Kubernetes to check if the application is ready (can get traffic) and if it is in a broken state (pod should be killed and restarted for ex.). It is part of fusion-observability module.\nMetrics: often coupled to prometheus or opentelemetry, it enables to collect metrics (think time series) about your application. It can be technical (CPU usage for ex.) or business (number of downloads, number of open pages by session). It is part of fusion-observability module.\nTracing: this is the ability to trace a business request (a trace) end to end through all the system. Main collectors/UI are Jaegger and Zipkin. Fusion supports that through its fusion-tracing module (see HTTP Server or HTTP Client modules).\nBy default, observability module adds another web server for observability purposes. Default port is 8181, but you can set fusion.observability.server.port configuration (system property, environment variable using underscores and uppercasing it) to override it.\nThe goal to not reuse the same server is to not have to secure this one (it will stay an internal port in your cluster/infrastructure). Since some Kubernetes tooling does not like adding headers to gather the data (prometheus for ex.) it is a good compromise.\nA health check implements io.yupiik.fusion.observability.health.HealthCheck API.\nThen the observability server will expose a /health endpoint which will return an HTTP 200 if all health checks are successful and an HTTP 503 if there is at least one failure.\nIf you need to distinguish between health check types, you can implement type() method and return something different from live.\nThen you can call the particular endpoints using /health?type=<my type>. To get the live checks, for example, use /health?type=live. Without type query parameter, all checks are executed.\nMetrics exposes an endpoint /metrics on observability server which renders the openmetrics stored in io.yupiik.fusion.observability.metrics.MetricsRegistry.\nIt supports Gauge and Counter metric types.\nHere is a common way to use it in your application:\nyou can unregister your counter on the registry if it is a short live counter (to use with a session for example), it will then no more be available but using that with prometheus, you have no guarantee it will be polled, so it can be neat to delay the un-registration until next polling. Gauge can make it easy using registerReadOnlyGauge since you then pass a LongSupplier you control.","title":"Observability","url":"//www.yupiik.io/fusion/fusion/observability.html"},{"lang":"en","lvl2":"Project definition\nConfiguration\nEntity\nQuerying","lvl3":"Default configuration\nOperation on entity\nCRUD\nAdvanced queries","text":"The Fusion Persistence module provides capabilities to deal with common database operations.\nFirst you need to add the fusion-persistence module in your pom.xml dependencies section:\nannotations - design API - is in fusion-build-api and is only useful at build time.\nYou need to add the tomcat-jdbc dependency to use TomcatDataSource pool:\nYou can find the full available properties to configure the pool here\nDefault configuration can implicitly configure a datasource if you set fusion.persistence.datasource.url value in system properties or environment variables (it uses io.yupiik.fusion.framework.api.configuration.Configuration).\nAll keys have fusion.persistence.datasource. prefix and follow org.apache.tomcat:tomcat-jdbc configuration (see https://tomcat.apache.org/tomcat-10.1-doc/jdbc-pool.html).\nHere are the available keys:\nfusion.persistence.datasource.defaultAutoCommit\nfusion.persistence.datasource.driver\nfusion.persistence.datasource.logAbandoned\nfusion.persistence.datasource.maxActive\nfusion.persistence.datasource.minEvictableIdleTime\nfusion.persistence.datasource.minIdle\nfusion.persistence.datasource.password\nfusion.persistence.datasource.removeAbandoned\nfusion.persistence.datasource.removeAbandonedTimeout\nfusion.persistence.datasource.testOnBorrow\nfusion.persistence.datasource.testOnReturn\nfusion.persistence.datasource.testWhileIdle\nfusion.persistence.datasource.timeBetweenEvictionRuns\nfusion.persistence.datasource.url\nfusion.persistence.datasource.username\nfusion.persistence.datasource.validationQuery\nfusion.persistence.datasource.validationQueryTimeout\nthis (implicit) datasource requires to define its bounds/transactions calling read or write wrapper, you can inject TomcatDataSource to have these methods.\nFusion support java record for database entity definition.\nActivate the record as an entity and setting the name enables to force the table name, if not set it is the simple class name which is used.\nIndicate the primary key of the entity. autoIncremented: It is recommended to use a UUID or equivalent as identifier but when mapping an existing database you can need to synchronize and use java.sql.Statement.getGeneratedKeys to map the keys. For these cases, set this toggle to true. If your model is a POJO the value is directly set but if it is a record the value will be copied at insert time. order: When using multiple times this annotation, enables to sort the fields.\nActivate the field as a column table. If the name is not set, the field name is used as column name.\nSome hooks are available and can be added in the entity record directly:\nIt’s very simple to execute common action, you just need to inject the database and use it with the entity.\nFusion database provide common in-house CRUD operations.\nFor advanced queries you can use a virtual table (it is a plain table but the @Table annotation is ignored) which would be used as project based on query aliases:\nwith JoinModel being something like:\nOr you can also use Entity binder capacity:","title":"Persistence","url":"//www.yupiik.io/fusion/fusion/persistence.html"},{"lang":"en","lvl2":"Maven","lvl3":"Simplest\nIDE/Jetbrains Idea\nUse ECJ compiler (Eclipse)\nDo not expose processor in code completion","text":"The framework uses three main modules:\nAPI: the runtime API, it is the runtime API, mainly resolution/look-up oriented\nBuild API: it is the API only required at build time, it is intended to be used to trigger the generation of the runtime classes using processor module,\nProcessor: it contains the magic generating most of the runtime and making the framework efficient and light.\nTherefore the project will generally get the api in scope compile, the build api in scope provided or optional and the processor either in scope provided/optional or just defined as an annotation processor in your compiler configuration.\nthe generation process assumes the annotation processor is aware of all classes, depending the tools you generate you can need to disable incremental compilation as of today to ensure all classes are seen by the generator.\nThe simplest is to just add the API (scope compile) and processor (scope provided):\nif can be sane to compile your project with maven (mvn compile or mvn process-classes) instead of relying on your IDE. This is indeed a general rule but, in this case, will enable to avoid the pitfalls of a fake incremental compilation (compiling only a few source files using the precompiled project output). This last case can lead to missing bean, you can obviously delete the target folder of your project to force your IDE to recompile but it is saner to just rely on a properly compile phase.\nUntil you configure IDEA to use maven to compile, it can happen it compiles a single source (at least not the whole module properly like Maven by default) so the output can miss some beans. If it happens (java: java.lang.IllegalArgumentException: Unsupported type: 'com.superbiz.MyJsonModel', known models: [….] at compile time or NoClassDefFoundError/No bean matching type '…' at test/runtime for example), then just Rebuild the project, command is in Build menu (shortcut: Alt+B → R by default).\nUltimately just drop the target/out folder if it is not about adding a file but more about removing a file (incremental support of such a change is not great as of today - but this is not specific to this project ;)).\nFor ECJ to work you need to ensure the argument -sourcepath is set in compiler configuration and import plexus-compiler-eclipse (Maven):\nA more advanced option would be to define the api in scope compile, the build API in scope provided and the processor only in maven-compiler-plugin.\nThis option is more complex in terms of configuration but has the advantage to not expose the processor in the IDE (completion).\nHere is what it can look like:\ndisabling the incremental compilation there is generally a good idea, in particular on CI but not having the processor in provided scope will make your IDE no more able to generate properly classes in general. So a better option can be to stick to previous dependencies only option (by default maven recompiles properly the module - don’t set <useIncrementalCompilation>false</useIncrementalCompilation> it means do not use incremental compilation).","title":"Setup","url":"//www.yupiik.io/fusion/fusion/setup.html"}]